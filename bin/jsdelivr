#!/usr/bin/env python
# -*- coding: utf-8 -*-
from itertools import imap, ifilter, izip
from pprint import pprint

import os
import re
import requests
import configparser


ROOT_REPO_URL = "https://api.github.com/repos/jimaek/jsdelivr/git/trees/master?recursive=1"


class Version(object):
    cdn_url_pattern = "//cdn.jsdelivr.net/%s"
    img_path_re = re.compile(r'.*\.(png|jpg|jpeg|gif)$')
    js_path_re = re.compile(r'.*\.(js)$')
    css_path_re = re.compile(r'.*\.(css)$')

    def __init__(self, name, version):
        self.name = name
        self.version = version
        self.files = []
        self.zip_file = None

    def add_file(self, file_path):
        if file_path.endswith("zip"):
            self.zip_file = file_path
        else:
            self.files.append(file_path)

    def _path(self, path):
        return path

    def _cdn(self, path):
        return self.cdn_url_pattern % path

    def _script_tag(self, path):
        return '<script type="text/javascript" src="%s"></script>' % self._cdn(path)

    def _link_tag(self, path):
        return '<link rel="stylesheet" type="text/css" href="%s" />' % self._cdn(path)

    def filter_files(self, regexp):
        return (path for path in self.files if regexp.match(path))

    def factory(regexp_attr_name, path_function_attr_name):
        def filter(self):
            regexp = getattr(self, regexp_attr_name)
            path_func = getattr(self, path_function_attr_name)
            files = self.filter_files(regexp)
            return [path_func(path) for path in files]
        return filter

    img = property(factory('img_path_re', '_path'))
    css = property(factory('css_path_re', '_path'))
    js = property(factory('js_path_re', '_path'))

    cdn_img = property(factory('img_path_re', '_cdn'))
    cdn_css = property(factory('css_path_re', '_cdn'))
    cdn_js = property(factory('js_path_re', '_cdn'))

    tag_css = property(factory('css_path_re', '_link_tag'))
    tag_js = property(factory('js_path_re', '_script_tag'))

    # cleanup
    del factory

    @property
    def cdn_files(self):
        return [self._cdn(file_path) for file_path in self.files]

    @property
    def cdn_zip_file(self):
        return self._cdn(self.zip_file)

    def download(self, local_path=None):
        file_name = local_path or "%s-%s.zip" % (self.name, self.version)
        resp = requests.get("http:%s" % self.cdn_zip_file)
        with open(file_name, 'w') as zipfile:
            zipfile.write(resp.content)

    def __unicode__(self):
        return u"<%s ver: %s>" % (self.name, self.version)

    __repr__ = __unicode__


class Lib(object):
    def __init__(self, name):
        self.name = name
        self.versions = {}

    def add_file(self, version, file_path):
        if version not in self.versions:
            ver = self.versions[version] = Version(self.name, version)
        else:
            ver = self.versions[version]
        ver.add_file(file_path)


class Registry(object):
    def __init__(self):
        self.libs = {}

    def add_lib_file(self, name, version, file_path):
        if name not in self.libs:
            self.libs[name] = Lib(name)
        self.libs[name].add_file(version, file_path)

    def get(self, name, version=None):
        lib = self.libs[name]
        if not version:
            return lib.versions[lib.versions.keys()[0]]
        return lib.versions[version]

    def get_many(self, names_with_version):
        return [
            self.get(name, version)
            for name, version in names_with_version
        ]


def parse_lib_file_path(node):
    node_path = node["path"]
    if node["type"] == "blob" and node_path.startswith("files"):
        path = node_path.split("/")
        if len(path) >= 3:
            return path[1], path[2], "/".join(path[1:])
    return None


def is_none(path):
    return bool(path)


def create_libs(tree_list):
    libs = Registry()

    for name, version, file_path in ifilter(is_none, imap(parse_lib_file_path, tree_list)):
        libs.add_lib_file(name, version, file_path)

    return libs


def lib_names():
    resp = requests.get(ROOT_REPO_URL)
    data = resp.json()
    libs = create_libs(data["tree"])
    jqr = libs.get("jquery")
    pprint(jqr.js)
    pprint(jqr.css)
    pprint(jqr.img)
    jqr.download()


# lib_names()


def here(*path):
    absolute_here = os.path.abspath(os.path.dirname(__file__))
    return os.path.abspath(os.path.join(absolute_here, *path))


def prepare_conf(conf):
    libs = ifilter(is_none, (
        lib.strip() for lib in conf['libs'].split('\n')
    ))
    libs = [
        tuple(lib.split("==")) if '==' in lib else (lib, None) for lib in libs
    ]
    conf.update(
        libs=libs,
        download=bool(conf.get('libs_root')),
    )
    return conf


def read_config(prepare=True):
    conf = configparser.ConfigParser()
    conf.read([here('jsdelivr_other.ini'), here('jsdelivr.ini')])
    data = dict(conf['jsdelivr'])
    if not prepare:
        return data
    return prepare_conf(data)


def main():
    conf = read_config()

    resp = requests.get(ROOT_REPO_URL)
    data = resp.json()
    libs = create_libs(data["tree"])
    jquery, boostrap = libs.get_many(conf["libs"])

    pprint(jquery.cdn_js)
    pprint(boostrap.tag_js)


if __name__ == '__main__':
    main()
